import exceptions, AcdOptiExceptions
#from collections import defaultdict

whitespace = (" ", "\n", "\t") #What is regarded as whitespace?

class DataDict():
    """
    Multimap-like order-preserving storage.
    Please don't modify arrays directly!

    Deletion/rearranging features may come later.
    """
    keys = None
    vals = None
    length = None
    def __init__(self):
        self.keys = []
        self.vals = []
        self.length = 0

    def pushBack(self, key, val):
        print "app"
        """
        Appends a (key,value) pair to the end of the storage
        """
        if (type(key) != str) or (type(val) != str):
            print key, val
            print type(key), type(val)
            raise AcdOptiExceptions.AcdOptiException_dataDict_notAString

        def tupleInString(str_in, tup_in):
            print str_in
            for t in tup_in:
                if t in str_in:
                    return True
            return False
        if tupleInString(key,whitespace) or tupleInString(val,whitespace):
            print "\"" + key + "\", \"" + val + "\""
            raise AcdOptiExceptions.AcdOptiException_dataDict_stringWithSpace

        self.keys.append(key)
        self.vals.append(val)
        self.length += 1
        print "hei"
        print self

    def getVals(self, key):
        """
        Returns all values associated with a given key,
        in the order they where pushBack'ed
        """
        retBuf = []
        for i in len(keys):
            if self.keys[i] == key:
                retBuf.append(self.vals[i])
    def __str__(self):
        """
        Prints a rudimentary representation of the dataDict
        """
        print "__str__()"
        retrs = ""
        print self.length
        for i in xrange(self.length):
            if not type(self.vals[i]) == DataDict:
                retrs += "(\"" + self.keys[i] + "\" , \"" + self.vals[i] + "\")\n"
            else:
                retrs += "DataDict"
        return retrs
        

class AcdOptiFileParser():
    """
    Base class for all file/stream parsers.
    All parsers, except baseclass,
    accepts the same __init__() arguments:
    - data: Either a filename pointing to the data,
        or a string with the same content as would a file,
        or a dataDict (in case of baseclass).
    - mode: A short string with flags indicating how
        to treat the data:
        "w"  : Writing a new file (if necessary truncating
            one that already excists) when the function
            "write()" is called with whatever is then in dataDict.
            Argument data is then the filename
        "r"  : Reads a file into dataDict
            Argument data is then the filename
        "rw" : Reads in init, then same behaviour as "w"
        "s"  : Same as "r", but data is a string containing
            data in the same format as would normally be used on disk
    
    To write data from a string or dataDict,
    first create one object of the correct input type
    then create another object in "w" mode for the output type,
    use importDataDict(), and then write().
    """
    def __init__(self,dataDict=None):
        """
        Baseclass does the same as children,
        but can't do file IO. This constructor
        may initialize from a dataDict.
        """
        importDataDict(dataDict)
        
    def importDataDict(self,dataDict_in=None):
        """
        This functions is usefull for converting between formats.
        Also used for initializing the dataDict.
        """
        if self.dataDict == None:
            self.dataDict = DataDict()
        if dataDict_in != None:
            for i in xrange(dataDict_in.length):
                self.dataDict.pushBack(dataDict_in.keys[i],dataDict_in.vals[i])
    #END importDataDict()
    
    dataDict = None

class AcdOptiFileParser_simple(AcdOptiFileParser):
    """
    Reads and writes ACD text files in the "simple" syntax,
    used by acdtool rfpost.
    
    Expected syntax example:
    Label
    {
    field = value
    field2 = value //Comment
    }
    """
    def __init__(self,data,mode):
        self.mode = mode
        
        if mode == "s":
            data_parsed = AcdOptiFileParser_simple.parseString(data) #May throw exception!
            print data_parsed
            self.importDataDict(data_parsed)
        elif mode == "r" or mode == "rw":
            #Read file
            ifile = open(data, 'r')
            datastr = ifile.read()
            ifile.close()
            
            #Parse
            data_parsed = AcdOptiFileParser_simple.parseString(datastr)
            self.importDataDict(data_parsed)
        elif mode == "w":
            #Create an empty dataDict
            self.importDataDict()
            pass
        else:
            raise AcdOptiExceptions.AcdOptiException_fileParser_invalidMode
    
    @staticmethod
    def parseString(str_in):
        """
        Class method which parses the string in "simple" syntax,
        and returns a DataDict. Uses recursion - calls itself if
        it hits a "{" with the contents between "{" and "}" as argument.
        """
        strBuf = ""
        keyBuf = None
        dictBuf = DataDict()

        idx = 0
        expectingMore = False #In the middle of a word
        inComment = False #In the middle of a comment (terminated by \n)

        while idx < len(str_in):
            print idx, keyBuf, strBuf, expectingMore, inComment
            if str_in[idx] in whitespace and not expectingMore:
                if str_in[idx] == "\n":
                    print "\\n whitespace"
                elif str_in[idx] == "\t":
                    print "\\t whitespace"
                elif str_in[idx] == " ":
                    print "_ whitespace"
                else:
                    print "?? whitespace"
                #More whitespace. Booring!
                idx += 1
                continue
            elif str_in[idx] == "=":
                print str_in[idx], "="
                if expectingMore:
                    #straigth off the keyword
                    assert keyBuf == None
                    keyBuf = strBuf
                    strBuf += 1
                    expectingMore = False
                idx += 1
                continue
            elif inComment:
                print str_in[idx], "InComment"
                #In a comment - done yet?
                if str_in[idx] == "\n":
                    inComment = False #Yes!
                idx += 1
                continue
            elif str_in[idx] in whitespace and expectingMore:
                print str_in[idx], "EndSomething"
                #End of something 
                if keyBuf == None:
                    #It was a key!
                    keyBuf = strBuf
                    strBuf = ""
                else:
                    #It was a value!
                    dictBuf.pushBack(keyBuf,strBuf)
                    keyBuf = None
                    strBuf = ""
                expectingMore = False
                idx += 1
                continue
            elif str_in[idx] not in (whitespace + ("/", "{"))   and not expectingMore:
                print str_in[idx], "BeginSomething"
                #Beginning of something (Not a comment)
                expectingMore = True
            elif str_in[idx] == "{":
                print str_in[idx], "Hit {"
                #Start a new nested DataDict
                if expectingMore:
                    #Came straigth off a keyword
                    assert keyBuf == None #This keyword should be the name of the dict
                    keyBuf = strBuf
                    strBuf = ""
                #Find the closing }
                idx +=1
                idx2 = idx
                while idx2 < len(str_in):
                    print "\t searching: ", str_in[idx2]
                    if str_in[idx2] == "}":
                        print "\t FOUND!"
                        strBuf = str_in[idx:idx2]
                        break
                    idx2 += 1
                if idx2 == len(str_in):
                    print "Ran off the end of the input string before \"{\" was closed"
                    raise AcdOptiExceptions.AcdOptiException_fileParser_invalidSyntax
                dictBuf.pushBack(keyBuf, AcdOptiFileParser_simple.parseString(strBuf)) #Recursively parse between { }
                keyBuf = None
                strBuf = ""
                idx = idx2
                continue
            elif str_in[idx] == "/":
                print str_in[idx], "Comment?"
                #Comment?
                if idx+1 == len(str_in) and str_in[idx+1] == "/":
                    #Comment!
                    if expectingMore:
                        #Save the key/value just seen
                        dictBuf.pushBack(keyBuf,strBuf)
                        keyBuf = None
                        strBuf = ""
                        expectingMore = False
                    idx+=2
                    inComment = True
                    continue
                #Fallthrough to continuation of data
            #END if...elif
            #Continuation of data
            print str_in[idx], "Data"
            strBuf += str_in[idx]
            idx += 1
        #END while
    #END parsestring()
        
    def __repr__(self):
        """
        Creates a string in the simple syntax in the same format
        as interpreted by parseString
        """
        raise exceptions.NotImplementedError

    def write(self):
        raise exceptions.NotImplementedError
    def __del__(self):
        raise exceptions.NotImplementedError
    
    fname = None
    mode = None

class AcdOptiFileParser_KVC(AcdOptiFileParser):
    """
    Reads and writes ACD text files in the "KVC" syntax,
    used by solver output file
    """
    def __init__(self,data,mode):
        raise exceptions.NotImplementedError
    
    def write(self):
        raise exceptions.NotImplementedError
    def __del__(self):
        raise exceptions.NotImplementedError


class AcdOptiFileParser_Lua(AcdOptiFileParser):
    """
    Reads and writes ACD text files in the "Lua" syntax,
    used by solver input params
    """
    def __init__(self,data,mode):
        raise exceptions.NotImplementedError
    def write(self):
        raise exceptions.NotImplementedError
    def __del__(self):
        raise exceptions.NotImplementedError
